// builtin = #import "builtin"
// builtin

test = @bool(Bool)
	if bool then
		1
	else
		2

/*
// routine_start (inputCount, localCount, outputCount) [] -> []

(routines (
	(routine_start 1 1) ; 0 (test)
		; typecheck arg
		(local_getType 0)
		(type bool)
		(assert_equal)
		
		; run if
		(local_getType 0)
		(if 1 2)
		
		; typecheck if
		; typeof 1 == typeof 2
		; f32 == f32
		; true
		(bool 0)
		(if 1 2)
		(getType)
		(bool 1)
		(if 1 2)
		(getType)
		(assert_equal)
		(routine_end)
	
	(routine_start 1 1) ; 1 (test_then)
		(f32 1)
		(routine_end)
	
	(routine_start 1 1) ; 2 (test_else)
		(f32 2)
		(routine_end)
))
*/

// a = 1

// getType = @T(Type) T

// add1 = @x(getType Float64) x + 1
// add1 4

// test = &{
// 	a = 1
// 	b = 2
// }

// add1 = @x(builtin.Float64) x + 1
// add1 4

// add = @a(builtin.Float64) @b(builtin.Float64) a + b
// add 1

// fib = @n(builtin.Float64)
// 	if n <= 1 then
// 		n
// 	else
// 		(fib n - 1) + (fib n - 2)

// fib 2

// Number = builtin.Float64
// a = @x(Number)
// 	if x <= 0 then
// 		0
// 	else
// 		b x - 1
// b = @x(Number)
// 	if x <= 0 then
// 		0
// 	else
// 		a x - 1

// a 1
// b 2

// ---------------

// tests = {
// 	mySortTests = makeSortTest mySort
// 	fibTest =
// 		(fib 1) == 1 &&
// 		(fib 2) == 1 &&
// 		(fib 3) == 2 &&
// 		(fib 4) == 3 &&
// 		(fib 5) == 5
// }

// ---------------

// string = "Hello, World"
// string

// Vec2 = {
// 	__traits__ = {
// 		builtin.typedValue = {
// 			getType = @value(Vec2) Vec2
// 		}
// 	}
// }

// Vec2 = {
// 	__prototype__ = Type
// 	fields = {
// 		x = Number
// 		y = Number
// 	}
	
// 	new = @x(:Number) @y(:Number)
// 		&Vec2{
// 			x = x,
// 			y = y
// 		}
	
// 	add = @v1(Vec2) @v2(:Vec2)
// 		(+) = Number.+
// 		&Vec2{
// 			x = v1.x + v2.x,
// 			y = v1.y + v2.y
// 		}
// }

// a = Vec2.new x: 1 y: 2
// b = Vec2.new x: 10 y: 20

// Vec2.add a to: b

// Case = {
// 	__prototype__ = Enum
// 	tag = 0
// 	value = {...}
// }